---
title: "Pathfinder WS1 | NAME_OF_DATASET"
subtitle: "Pre-imputation SNP QC report"
author: 
- "Leon Hubbard"
- "Antonio F. Pardi√±as"
date: "`r format(Sys.Date(), '%d-%m-%Y')`"

output: 
  prettydoc::html_pretty:
    theme: leonids
    highlight: vignette
    fig_caption: yes
    toc: FALSE
    toc_depth: 2
    number_sections: FALSE
params:
  DATASET: ""
---

---
# NOTE: With the current settings ("setup" chunk), no code or warnings will be shown in the output.
# When running an analysis for the first time, please inspect the console output as well as the plots.
--- 

```{r setup, include=FALSE}
library("knitr")
library("prettydoc")
knitr::opts_chunk$set(echo=F, tidy=T, cache=F, message=F, error=F, warning=F, comment=NA, out.width = '95%')
opts_knit$set(width = 75)
options(formatR.arrow=T, max.print = "75")
```

```{r packages, include=FALSE}

### Note script runs with these packages and versions
library("tidyverse") # Package version: 1.2.1
library("ggthemes") # Package version: 4.0.1
library("scales") # Package version 1.0.0
library("RColorBrewer") # Package version 1.1-2
library("evaluate") # devtools::install_github('hadley/evaluate')
library("data.table") # Package version 1.12.0
library("rvest") # Package version 0.3.2
# library("BiocManager") # Use to install/update Bioconductor packages. Bioconductor version 3.8. Package version 1.30.4
library("GWASTools") # Bioconductor package : Package version: 1.28.0
library("SNPRelate") # Bioconductor package. Package version: 1.16.0
library("GENESIS") # Bioconductor package. Package version: 2.12.2
library("snpStats") # Bioconductor package. Package version: 1.32.0
library("kableExtra") # Package version: 1.0.0
library("gridGraphics") # Package version: 0.3-3
library("cowplot") # Package version 0.9.4
library("AssocTests") # Package version:0.0-4 
library("caret") # Package version: 6.0-81
```

```{r paths, include=FALSE}

evaluate::inject_funs(system = function(...) cat(base::system(..., intern = TRUE), sep = "\n"))

### miscfolder contains software / R packages and other miscelanious files required during the pipeline.
miscfolder="FULL PATH TO /GenoQCPipeExtra"

SEXUPDATE=F
FIDUPDATE=F
DATASET=params$DATASET
DATASET.NAME=DATASET
REF.PANEL="HGDP_SAGP.grc37.qc"
outpath="FULL PATH TO YOUR GENOTYPE DATA"
outpath=paste(outpath,"/",DATASET,sep="")
setwd(outpath)
if(dir.exists(outpath)==F){
dir.create(outpath)
} 

dir.create("Genotypes")
dir.create("Genotypes/OriginalGenotypes")

PLINK=paste(miscfolder,"/plink1.9",sep="") # PLINK v1.9
PLINK2=paste(miscfolder,"/plink2",sep="") # PLINK v2 alpha
GH=paste(miscfolder,"/GenotypeHarmonizer-1.4.20-SNAPSHOT/GenotypeHarmonizer.sh",sep="")
vcfsort=paste(miscfolder,"/vcf-sort",sep="")
liftover=paste(miscfolder,"/liftOverPlink.py",sep="")
```

```{r qc parameters, include=FALSE}
set.seed(12062017)
qc0.max.femaleF <- 0.2 # Maximum female X-linked homozygosity
qc0.min.maleF <- 0.8 # Minimum male X-linked homozygosity
qc1.call.rate <- 0.95 # Minimum marker call rate
qc2.coverage <- 0.95 # Minimum individual genotyping coverage
qc3.hwepval <- 1e-6 # Maximum mid p-value for the HWE test
qc4.maf <- 0.01 # Minimum MAF for PCA
qc4.pcairs <- 5 # Number of PCs used to correct kinship matrix
qc4.kin <- 0.1 # Minimum kinship to include pairs of samples in report
max.aimpcs <- 32 # Follows Sophie's paper
min.prob.aim1 <- 0.8 # Minimal ancestry percentage to classify one person
min.prob.admx <- 0.4 # Minimal ancestry percentage to send a person
min.prob.aim2 <- 0.8 # Minimal ancestry percentage to classify one person
Merged<-T # Select T if the dataset is comprised of merged genotype data 
```

---
# NOTE: 1) Check if genotype data is ped/map or bed/bim/fam 
#       i) If ped/map, creates a bed/bim/fam.
--- 
```{r 1i, include=F,eval=F}

### GENDER UPDATE ASSUMES THAT THE FID CORRESPONDS TO THE PHENOTYPE ID
if(file.exists(paste(outpath,"/",DATASET,".ped",sep=""))==T){
  if(FIDUPDATE==T & SEXUPDATE==T){
    system(paste(miscfolder,"/plink1.9 --file ",outpath,"/",DATASET," --make-bed --update-ids ",DATASET,".updateids --out ",outpath,"/",DATASET,".IDUPDATE",sep=""))
    system(paste(miscfolder,"/plink1.9 --bfile ",outpath,"/",DATASET,".IDUPDATE --make-bed --update-sex ",DATASET,".updatesex --out ",outpath,"/",DATASET,sep=""))
    
  } else if(FIDUPDATE==T & SEXUPDATE==F){
        system(paste(miscfolder,"/plink1.9 --file ",outpath,"/",DATASET," --make-bed --update-ids ",DATASET,".updateids --out ",outpath,"/",DATASET,".IDUPDATE",sep=""))
    
  } else if(FIDUPDATE==F & SEXUPDATE==T){
     system(paste(miscfolder,"/plink1.9 --file ",outpath,"/",DATASET," --make-bed --update-sex ",DATASET,".updatesex --out ",outpath,"/",DATASET,sep=""))
    
  } else if (FIDUPDATE==F & SEXUPDATE==F){
    system(paste(miscfolder,"/plink1.9 --file ",outpath,"/",DATASET," --make-bed --out ",outpath,"/",DATASET,sep=""))
  }
}

if(file.exists(paste(outpath,"/",DATASET,".ped",sep=""))==F){
    
    ### We are moving the original genotype files to a different folder so the updated files can be renamed to that of the original file to avoid lengthy code re-writes 
    system(paste(miscfolder,"/plink1.9 --bfile ",outpath,"/",DATASET," --make-bed --update-ids ",DATASET,".updateids --out ",outpath,"/",DATASET,".IDUPDATE",sep=""))
    system(paste("mv ",DATASET,".bed Genotypes/OriginalGenotypes/",sep=""))
    system(paste("mv ",DATASET,".bim Genotypes/OriginalGenotypes/",sep=""))
    system(paste("mv ",DATASET,".fam Genotypes/OriginalGenotypes/",sep=""))
    
    system(paste(miscfolder,"/plink1.9 --bfile ",outpath,"/",DATASET,".IDUPDATE --make-bed --update-sex ",DATASET,".updatesex --out ",outpath,"/",DATASET,sep=""))
}

### This chunk only runs if individuals have already been identified for removal
if(file.exists(paste(DATASET,".manual.qc0.remove",sep=""))==T){
system(paste0(PLINK," --bfile ",outpath,"/",DATASET," --remove ",DATASET,".manual.qc0.remove --make-bed --out ",outpath,"/",DATASET,".excluded.inds"))
    system(paste("mv ",DATASET,".excluded.inds.bed ",DATASET,".bed",sep=""))
    system(paste("mv ",DATASET,".excluded.inds.bim ",DATASET,".bim",sep=""))
    system(paste("mv ",DATASET,".excluded.inds.fam ",DATASET,".fam",sep=""))
  }

```

---
# NOTE: 2) Checks bim file for number of chromosomes in data
#       i) If < 22 then stops
#	      ii) If >=22 then continues
--- 
```{r 2i and 2ii, include=F}
bim <- read_table2(paste0(DATASET,".bim"), col_names=c("CHR","SNP","cm","BP","A1","A2"),col_types="cciicc")
if(length(unique(bim$CHR))<22){
  stop(paste("There are only ",length(unique(bim$CHR))," chromosomes in the bim file. Check for CHR coding issues.",sep=""))
}

bim.problem.chr=bim[which(bim$CHR<0),]
if(nrow(bim.problem.chr)>0){
	write.table(as.data.frame(bim.problem.chr$SNP),file=paste(outpath,"/BadChrSNPs.txt",sep=""),col.names=F,quote=F,row.names=F)
}


```

---
# NOTE: 3) Checks bim file for "B" allele counts
#	         i) If "B" alleles are present then stops
#	         ii) If not the pipeline continues
--- 
```{r 3i, include=FALSE}
bim.a1=as.data.frame(table(bim$A1))
bim.a2=as.data.frame(table(bim$A2))
b.allele.count=nrow(bim[which(bim$A1=="B" | bim$A2=="B"),])
if(b.allele.count>0){
  stop(paste("There are ",b.allele.count," SNPs with a B allele. Check for allele coding issues.",sep=""))
}

rm(list = c("bim.a1","bim.a2","b.allele.count"))
gc()
```

---
# NOTE: 4) Identifies the total number of individuals with genotyping information
#	      i) Reports number using total number in fam file
---
```{r 4i, include=FALSE}
# Read in data from PLINK files
fam <- read_table2(paste0(outpath,"/",DATASET,".fam"), col_names=c("FID","IID","PatID","MatID","Sex","Pheno"), col_types="ccccii")
bim <- read_table2(paste0(outpath,"/",DATASET,".bim"), col_names=c("CHR","SNP","cm","BP","A1","A2"), col_types="cciicc")
bim$CHR=gsub("M","26",gsub("MT","26",gsub("Y","24",gsub("X","23",bim$CHR))))
bim$CHR[grep("-",bim$CHR)]=0
bim$LOC=paste(bim$CHR,":",bim$BP,sep="")
```

## Sample information

The **`r DATASET`** sample contains available genotypes for `r nrow(fam)` individuals.

---
# NOTE: 5) Performs best guess genotype chip by looking at SNP coordinates (chr:bp)
#	      i) Compares number of overlapping SNPs with 391 genotyping platforms / builds
#	      ii) Reports total number of genotyped SNPs and the closest matching genotyping platform 
---
```{r 5i & 5ii, include=FALSE,eval=T}
# i) Compares number of overlapping SNPs with 391 genotyping platforms and builds

list.chips=grep("txt",list.files(paste(miscfolder,"/ChipendiumSNPCoords/",sep=""),full.names = T),value=T)
CHIP.OVERLAP=as.data.frame(do.call(rbind,lapply(list.chips,function(CHIP){
  CHIPPY=as.data.frame(fread(input=CHIP,stringsAsFactors = F,header=F))
  OVERLAP=bim[bim$LOC %in% unlist(CHIPPY$V1),]$LOC
  cbind(length(OVERLAP),as.character(CHIP))
})))
names(CHIP.OVERLAP)=c("OverlappingSNPs","CHIP")
CHIP.OVERLAP$OverlappingSNPs=as.numeric(as.character(CHIP.OVERLAP$OverlappingSNPs))
CHIP.OVERLAP=CHIP.OVERLAP[order(CHIP.OVERLAP$OverlappingSNPs),]

# ii) Reports total number of genotyped SNPs and the closest matching genotyping platform
BestGuessChip=gsub("-strand.zip","",CHIP.OVERLAP[which(CHIP.OVERLAP$OverlappingSNPs==max(CHIP.OVERLAP$OverlappingSNPs)),][1,2])
BestGuessChip=as.data.frame(do.call(rbind,strsplit(BestGuessChip,split = "//")))[2]
BestGuessChip$V2=as.character((BestGuessChip$V2))
BestGuessChip=gsub(".processed.txt","",BestGuessChip)
#BestGuessOverlap=CHIP.OVERLAP[which(CHIP.OVERLAP$OverlappingSNPs==max(CHIP.OVERLAP$OverlappingSNPs)),][1,1]
```

There are `r nrow(bim)` genotyped markers. The best-guess genotyping platform based on concordant SNP coordinates is the **`r BestGuessChip`**.

To maximise the number of SNPs available for imputation, we use Genome-Harmoniser (Deelen at al 2014, PMID: [25495213](https://www.ncbi.nlm.nih.gov/pubmed/25495213)) to resolve strand allignment, discordant alleles and coordinate mismatches for SNPs in common between the dataset and imputation reference panel (Haplotype Reference Consortium 2016, PMID: [27548312](https://www.ncbi.nlm.nih.gov/pubmed/27548312). See  http://www.haplotype-reference-consortium.org/home for more details).

---
# NOTE: 6) Identifies Mitochondrial SNPs and those with chr "0"
#	      i) Removes SNPs with chr 0
#	      ii) Removes mitochrondrial SNPs from main bed/bim/fam (if applicable)
#	      iii) Saves mitochondrial SNPs with chr codes "26" or "MT" or "M" to a new bed/bim/fam and reports total number (if applicable)
---
```{r 6i, 6ii and 6iii , include=FALSE}

bim.no.chr=bim[bim$CHR <= 0,]
bim <- bim[bim$CHR != 0,] # Discard markers with no chromosome
mito=bim[bim$CHR == 26 | bim$CHR=="M" | bim$CHR=="MT" ,]

### IF N MITOCHONDRIA SNPS > 0 AND SNPS WITH 0 CHR > 0
if(nrow(mito)>0){
write.table(as.data.frame(mito$SNP),file=paste(outpath,"/",DATASET,".MitochondriaSNPs.txt",sep=""),col.names=T,row.names=F,quote=F)
system(paste0(PLINK," --allow-extra-chr --bfile ",outpath,"/",DATASET," --extract ",outpath,"/",DATASET,".MitochondriaSNPs.txt --make-bed --out ",outpath,"/",DATASET,".Mitochondria"),ignore.stderr = T)

excludesnps=rbind(mito,bim.no.chr)
write.table(as.data.frame(excludesnps$SNP),file=paste(outpath,"/",DATASET,".MitochondriaSNPsand0s.txt",sep=""),col.names=T,row.names=F,quote=F)
system(paste0(PLINK," --allow-extra-chr --bfile ",DATASET," --exclude ",outpath,"/",DATASET,".MitochondriaSNPsand0s.txt --make-bed --out ",DATASET,"1"),ignore.stderr = T)
} else if(nrow(mito)==0 & nrow(bim.no.chr)>0){
  
### IF N MITOCHONDRIA SNPS = 0 AND SNPS WITH 0 CHR > 0
excludesnps=bim.no.chr
write.table(as.data.frame(excludesnps$SNP),file=paste(outpath,"/",DATASET,".MitochondriaSNPsand0s.txt",sep=""),col.names=T,row.names=F,quote=F)
system(paste0(PLINK," --allow-extra-chr --bfile ",DATASET," --exclude ",outpath,"/",DATASET,".MitochondriaSNPsand0s.txt --make-bed --out ",outpath,"/",DATASET,"1"),ignore.stderr = T)

} else if(nrow(mito)==0 & nrow(bim.no.chr)==0){
system(paste0(PLINK," --bfile ",outpath,"/",DATASET," --make-bed --out ",outpath,"/",DATASET,"1"), ignore.stderr = T)
}

if(nrow(mito) == 0 ){
  mito.text=cat(paste0("No mitochrondrial SNPs were present in the dataset"))
} else if(nrow(mito) > 0 ){
mito.text= cat(paste0(nrow(mito)," mitochrondrial markers have been removed from core dataset but saved for posterity in ",DATASET,".Mitochondria.bed/bim/fam"))
}
```
  
---
# NOTE: 7) Checks for biological and reported gender and flags discrepencies
#	      i) Gender check using X Chr Data
#		    ii) Derive Y Chr call rates to be used later
#		    iii) Log discrepencies in output
---

```{r 7i 7ii and 7iii, include=FALSE}

### Gender check using X Chr Data
if(nrow(bim[bim$CHR %in% c("23","X"),])>0){
xsnps=bim[bim$CHR %in% c("23","X"),]
system(paste0(PLINK," --bfile ",outpath,"/",DATASET,"1 --check-sex ",qc0.max.femaleF," ",qc0.min.maleF," --out ",outpath,"/",DATASET,".qc0.x"),ignore.stderr = T)
qc0.dataset <- read_table2(paste0(outpath,"/",DATASET,".qc0.x.sexcheck"))
qc0.dataset$F[qc0.dataset$F<=0] <- 0 # Discard negative estimates (heterozygote sampling noise)

qc0.dataset.problem <- qc0.dataset[qc0.dataset$STATUS == "PROBLEM" & qc0.dataset$PEDSEX>0,]
qc0.dataset.problem1 <- qc0.dataset[qc0.dataset$PEDSEX==0,]


if(max(fam$Sex)>0){
 write.table(subset(qc0.dataset.problem,select=c("FID","IID")), paste0(outpath,"/",DATASET,".qc0.remove"), quote=F,col.names = F,row.names=F)
}

if(max(fam$Sex) > 0 ) {
  system(paste0(PLINK," --bfile ",outpath,"/",DATASET,"1 --remove ",DATASET,".qc0.remove --make-bed --out ",outpath,"/",DATASET,".qc0.clean"))
  } else if(max(fam$Sex) <= 0 ){
    system(paste0(PLINK," --bfile ",outpath,"/",DATASET,"1 --make-bed --out ",outpath,"/",DATASET,".qc0.clean"))
  }
} else if(nrow(bim[bim$CHR %in% c("23","X"),])==0){
    system(paste0(PLINK," --bfile ",outpath,"/",DATASET,"1 --make-bed --out ",outpath,"/",DATASET,".qc0.clean"))
}


### Derive Y Chr call rates to be used later and save Y chr data to new bed/bim/fam
if(nrow(bim[bim$CHR %in% c("24","Y"),])>0){

ysnps=bim[bim$CHR == 24 | bim$CHR=="Y",]
write.table(as.data.frame(ysnps$SNP),file=paste(outpath,"/",DATASET,".YSNPs.txt",sep=""),col.names=F,row.names=F,quote=F)
system(paste0(PLINK," --bfile ",outpath,"/",DATASET,"1 --extract ",outpath,"/",DATASET,".YSNPs.txt --make-bed --out ",outpath,"/",DATASET,".Y"), ignore.stderr = T)
system(paste0(PLINK," --bfile ",outpath,"/",DATASET,".Y --check-sex y-only --out ",outpath,"/",DATASET,".qc0.y"), ignore.stderr = T)

qc0.y.dataset <- read_table2(paste0(outpath,"/",DATASET,".qc0.y.sexcheck"))
### Obtain call rates
qc0.y.dataset <- subset(qc0.y.dataset,select=c("FID","IID","YCOUNT"))
qc0.y.dataset$YRATE <- qc0.y.dataset$YCOUNT / nrow(bim[bim$CHR %in% c("24","Y"),])

# Log discrepencies in output
if(max(fam$Sex) <= 0 ){
  cat(paste0("No individuals removed from the dataset after sex check because all gender phenotypes were missing"))
} else if(max(fam$Sex) > 0 ){
cat(paste0(nrow(qc0.dataset.problem)," individuals removed from the dataset after sex check"))
}
}
```


---
# NOTE: 8) Runs genome-harmoniser using the Haplotype Reference Consortium v1.1 reference panel
#i) Runs genome-harmoniser and produces a report for why each SNP is excluded
#ii) After harmonisation, checks for duplicate RS IDs. If there are duplicate IDs this causes issues at step X.
#iii) Checks for total number of SNPs removed by GH. If the total number of SNPs retained is > 2/3, the pipeline continues otherwise runs liftover to update build from hg18 to hg19 and creates new bed/bim/fam
#iv) Re-runs genome-harmoniser. If the number of SNPs removed is >2/3 the pipeline stops
---
```{r 8i 8ii 8iii 8iv 8v 8vi and 8vii, include=FALSE}

#i) Runs genome-harmoniser and produces a report for why each SNP is excluded
bim=as.data.frame(fread(input=paste(outpath,"/",DATASET,".qc0.clean.bim",sep=""),header=F))
bim$V1=gsub("23","X",bim$V1)
write.table(bim,file=paste(outpath,"/",DATASET,".qc0.clean.bim",sep=""),col.names=F,quote=F,row.names=F,sep="\t")
system(paste(GH," --asf --input ",outpath,"/",DATASET,".qc0.clean --ref ",miscfolder,"/HRC.r1-1.GRCh37.wgs.mac5.sites.vcf.gz --output ",outpath,"/",DATASET,".gh --ambiguousSnpFilter --update-id --mafAlign 0.1 -I PLINK_BED -R VCF",sep=""))
GH.REPORT=as.data.frame(fread(input=paste(outpath,"/",DATASET,".gh_snpLog.log",sep=""),header=T,stringsAsFactors = F))
GH.EXCLUDE=GH.REPORT[which(GH.REPORT$action=="Excluded"),]
write.table(GH.EXCLUDE$id,file=paste(outpath,"/",DATASET,".GH.HRC.Excluded.SNPs.txt",sep=""),col.names=F,quote=F,row.names=F)

#ii) After harmonisation, checks for duplicate RS IDs. If there are duplicate IDs this causes issues when deriving kinship. If there are duplicate IDs, the SNP being renamed (causing a duplicate ID) is removed. Genome-harmomiser is re-run excluding these SNPs
bim.gh=read_table2(paste0(outpath,"/",DATASET,".gh.bim"), col_names=c("CHR","SNP","cm","BP","A1","A2"))
bim.gh.dups=bim.gh[which(duplicated(bim.gh$SNP)==T),]$SNP
if(length(bim.gh.dups)>0){
  snpidlog=as.data.frame(fread(input=paste(outpath,"/",DATASET,".gh_idUpdates.txt",sep=""),header=T,stringsAsFactors = F))
  original.id=as.data.frame(snpidlog[snpidlog$newId %in% unlist(bim.gh.dups),]$originalId)
  write.table(original.id,file=paste(outpath,"/",DATASET,".Remove.Duplicated.SNP.txt",sep=""),col.names=F,quote=F,row.names=F)
  system(paste(PLINK," --bfile ",outpath,"/",DATASET,".qc0.clean --exclude ",outpath,"/",DATASET,".Remove.Duplicated.SNP.txt --make-bed --out ",outpath,"/",DATASET,".qc0.clean.nodups",sep=""))

bim=as.data.frame(fread(input=paste(outpath,"/",DATASET,".qc0.clean.nodups.bim",sep=""),header=F))
bim$V1=gsub("23","X",bim$V1)
write.table(bim,file=paste(outpath,"/",DATASET,".qc0.clean.nodups.bim",sep=""),col.names=F,quote=F,row.names=F,sep="\t")  

system(paste(GH," --input ",outpath,"/",DATASET,".qc0.clean.nodups --ref ",miscfolder,"/HRC.r1-1.GRCh37.wgs.mac5.sites.vcf.gz --output ",outpath,"/",DATASET,".gh --ambiguousSnpFilter --update-id --mafAlign 0.1 -I PLINK_BED -R VCF",sep=""))
}

#iii) Checks for total number of SNPs removed by GH. If 2/3 of SNPs are lost after harmonisation, the pipeline continues otherwise runs liftover to update build from hg18 to hg19 and creates new bed/bim/fam
 if(nrow(bim.gh)/nrow(bim)<=(1/3)){
  warning(paste("Over 2/3 of SNPs have been removed by Genome Harmoniser. Check for build issues.",sep=""))

  ### Use if statament to create a ped / map if this does not exist - if it does this will not re-create it and risk overwriting the orignal data
  if(file.exists(paste(outpath,"/",DATASET,".ped",sep=""))==F){
    system(paste(PLINK," --allow-no-sex --bfile ",outpath,"/",DATASET, " --recode --out ",outpath,"/",DATASET,sep=""))
  } else if(file.exists(paste(DATASET,".ped",sep=""))==T){
  system(paste(PLINK," --file ",outpath,"/",DATASET," --make-bed --out ",outpath,"/",DATASET,sep=""))
}
  system(paste(liftover," -e ",miscfolder,"/liftOver -c ",miscfolder,"/hg18ToHg19.over.chain.gz -m ",DATASET,".map -p ",DATASET,".ped -o ",DATASET,".grc37",sep=""))
    system(paste(PLINK," --allow-no-sex --file ",outpath,"/",DATASET,".grc37 --make-bed --out ",outpath,"/",DATASET,".grc37",sep=""))
    system(paste(GH," --asf --input ",outpath,"/",DATASET,".grc37 --ref ",miscfolder,"/HRC.r1-1.GRCh37.wgs.mac5.sites.vcf.gz --output ",outpath,"/",DATASET,".gh --ambiguousSnpFilter --update-id --mafAlign 0.1 -I PLINK_BED -R VCF",sep=""))
    GH.REPORT=as.data.frame(fread(input=paste(outpath,"/",DATASET,".gh_snpLog.log",sep=""),header=T,stringsAsFactors = F))
    GH.EXCLUDE=GH.REPORT[which(GH.REPORT$action=="Excluded"),]
    write.table(GH.EXCLUDE$id,file=paste(outpath,"/",DATASET,".GH.HRC.Excluded.SNPs.PostLiftover.txt",sep=""),col.names=F,quote=F,row.names=F)
    bim.gh=read_table2(paste0(outpath,"/",DATASET,".gh.bim"), col_names=c("CHR","SNP","cm","BP","A1","A2"))
    if(nrow(bim.gh)/nrow(bim)<=(1/3)){
    stop(paste("Over 2/3 of SNPs have still been removed by Genome Harmoniser. Check for build issues.",sep=""))
    }
  } 


rm(list=c("GH.REPORT","GH.EXCLUDE","bim.gh"))
gc()
``` 

## QC Step 1: SNP Missingness Rates

Markers in which the genotyping has performed poorly can be identified by assessing their call rates over the whole dataset (Turner 2011, PMID: [21234875](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3066182/)). SNPs with a low call rate are more likely to be plagued by genotyping errors, and thus should be excluded from further analyses.

---
# NOTE: 9) Identifies SNPs low genotyping rates < specified threshold, writes to file and generates plot
#	      i) Generates genotype rates per SNP 
#       ii) Creates a plot of genotype rates per SNP
#	      iii) Writes list of SNPs to exclude and creates new bed/bim/fam with qc1 suffix
---
```{r 9i, include=FALSE}

#i) i) Generates missingness rates per individual

system(paste0(PLINK," --bfile ",outpath,"/",DATASET,".gh --missing --out ",outpath,"/",DATASET,".qc1"), ignore.stderr = T)
#	      ii) If no SNPs are excluded then bed/bim/fam is created with qc1 suffix 
qc1.dataset <- read_table2(paste0(outpath,"/",DATASET,".qc1.lmiss"))
qc1.dataset$F_GENO <- 1 - qc1.dataset$F_MISS
qc1.dataset <- qc1.dataset[order(qc1.dataset$F_GENO),]
```

```{r 9ii, fig.align="center"}

#ii) Creates a plot of genotype rates per SNP 

qc1.dataset$Q <- (1:dim(qc1.dataset)[1])/(dim(qc1.dataset)[1]-1)
qc1.dataset.p1 <- ggplot(qc1.dataset, aes(x = Q, y= F_GENO)) +
  geom_point(shape=21, alpha = 1/2,size = 5, colour="darkgreen", fill="white") +
  geom_hline(yintercept=qc1.call.rate, linetype="dotted", colour="red") +
  labs(title="Marker missingness",y="Call Rate",x="Quantile",color="") +
  theme_fivethirtyeight(base_family="sans") +
  theme(plot.background = element_rect(fill = "white"),
        axis.title=element_text())
qc1.dataset.p1
```

```{r 9iii, include=FALSE}
#iii) Writes list of SNPs to exclude and creates new bed/bim/fam with qc1 suffix

qc_step=2

qc1.dataset.problem <- qc1.dataset[qc1.dataset$F_GENO < qc1.call.rate,]
if(nrow(qc1.dataset.problem)>0) {
  write.table(subset(qc1.dataset.problem,select=c("SNP")), paste0(outpath,"/",DATASET,".qc1.exclude"), quote=F,col.names = F,row.names=F) 
   system(paste0(PLINK," --bfile ",outpath,"/",DATASET,".gh --not-chr 0 --exclude ",outpath,"/",DATASET,".qc1.exclude --make-bed --out ",outpath,"/",DATASET,".qc1.clean"))
  } else {
    system(paste0(PLINK," --bfile ",outpath,"/",DATASET,".gh --not-chr 0 --make-bed --out ",outpath,"/",DATASET,".qc1.clean"))
    }
```

Optimal per-marker call rate was set at `r percent(qc1.call.rate)`. `r nrow(qc1.dataset.problem)` SNPs were removed due to low call rate.


## QC Step 2: Sample Missingness Rates

Similarly to the previous step, a large proportion of SNP assays failing on a single individual may be indicative of a poor quality DNA sample, which leads to aberrant genotype calling (Turner 2011, PMID: [21234875](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3066182/)). These samples should be removed from the dataset.

---
# NOTE: 10) Identifies individual low genotyping rates < specified threshold, writes to file and generates plot
#	      i) Generates genotype rates per individual 
#       ii) Creates a plot of genotype rates per individual
#	      iii) Writes list of individuals to exclude and creates new bed/bim/fam with qc2 suffix
---
```{r 10i, include=FALSE}
#i) Generates genotype rates per individual
system(paste0(PLINK," --bfile ",outpath,"/",DATASET,".qc1.clean --missing --out ",outpath,"/",DATASET,".qc2"), ignore.stderr = T)

qc2.dataset <- read_table(paste0(outpath,"/",DATASET,".qc2.imiss"))
qc2.dataset$F_GENO <- 1 - qc2.dataset$F_MISS
qc2.dataset <- qc2.dataset[order(qc2.dataset$F_GENO),]
```

```{r 10ii, fig.align="center"}
#ii) Creates a plot of genotype rates per individual
qc2.dataset$Q <- (1:dim(qc2.dataset)[1])/(dim(qc2.dataset)[1]-1)
qc2.dataset.p1 <- ggplot(qc2.dataset, aes(x = Q, y= F_GENO)) +
  geom_point(shape=21, alpha = 0.75,size = 5, colour="darkgreen", fill="white") +
  scale_y_continuous(limits = 0:1) +
  geom_hline(yintercept=qc2.coverage, linetype="dotted", colour="red") +
  labs(title="Individual missingness",y="Coverage",x="Quantile",color="") +
  theme_fivethirtyeight(base_family="sans") +
  theme(plot.background = element_rect(fill = "white"),
        axis.title=element_text())
qc2.dataset.p1
```


```{r 10iii, include=FALSE}
#iii) Writes list of individuals to exclude and creates new bed/bim/fam with qc2 suffix
qc_step=3
qc2.dataset.problem <- qc2.dataset[qc2.dataset$F_GENO < qc2.coverage,]
if(nrow(qc2.dataset.problem)>0) {
  write.table(subset(qc2.dataset.problem,select=c("FID","IID")), paste0(outpath,"/",DATASET,".qc2.remove"), quote=F,col.names = F,row.names=F) 
  system(paste0(PLINK," --bfile ",outpath,"/",DATASET,".qc1.clean --remove ",outpath,"/",DATASET,".qc2.remove --make-bed --out ",outpath,"/",DATASET,".qc2.clean"))
  } else{
    system(paste0(PLINK," --bfile ",outpath,"/",DATASET,".qc1.clean --make-bed --out ",outpath,"/",DATASET,".qc2.clean"))
  }

cat(paste0(nrow(qc2.dataset.problem)," individuals were removed due to low genotyping coverage (QC step ",qc_step,")"))
```
Optimal per-sample coverage was set at `r percent(qc2.coverage)`. `r nrow(qc2.dataset.problem)` individuals were removed due to low genotyping coverage.


## QC Step 3: Hardy-Weinberg equilibrium

Allele frequencies in random-mating populations usually follow the Hardy-Weinberg proportions, unless they are under strong selective pressures. Errors in genotyping tend to create deviations from HWE, as they result in a greater number of heterozygote calls (Graffelman 2017, PMID: [28374190](https://link.springer.com/article/10.1007%2Fs00439-017-1786-7)). At this step, only markers with large deviations from the equilibrium ($p_{mid} \leq$ `r sfsmisc::pretty10exp(qc3.hwepval, drop.1=T, lab.type = 'latex')[[1]]`) are removed.

---
# NOTE: 11) 	
#       i) Creates new bed/bim/fam with these SNPs excluded with qc3 suffix
#	      ii) If no individuals are excluded then bed/bim/fam is created with qc3 suffix
---
```{r 11i, include=FALSE}
### This uses the new HWE code included in the PLINK2 alpha which is adequate for sex-linked markers
qc_step=4

system(paste0(PLINK2," --bfile ",outpath,"/",DATASET,".qc2.clean --hwe midp ",qc3.hwepval," --make-bed --out ",outpath,"/",DATASET,".qc3.clean"))

qc1.bim <- read_table2(paste0(outpath,"/",DATASET,".qc1.clean.bim"), col_names=c("CHR","SNP","cm","BP","A1","A2"))
qc3.bim <- read_table2(paste0(outpath,"/",DATASET,".qc3.clean.bim"), col_names=c("CHR","SNP","cm","BP","A1","A2"), col_types = "ccnicc")
qc3.hwe <- qc1.bim[!(qc1.bim$SNP %in% qc3.bim$SNP),]
write.table(subset(qc3.hwe,select=c("SNP")), paste0(outpath,"/",DATASET,".qc3.exclude"), quote=F,col.names = F,row.names=F) 
```

`r nrow(qc3.hwe)` SNPs were removed due to failing the HWE test. 

## QC Step 4: Sex chromosome checks and abnormalities

This test assesses the match between the self-reported gender present in the PLINK files and the imputed sex inferred from homozygosity estimates from the X chromosome. Homozygosity at the X chromosome is assessed by the inbreeding coefficient F (Wright 1921, PMID: [17245962](http://www.genetics.org/content/143/4/1499)) calculated for each sample over all X-linked markers. Samples at the extremes of the distribution are likely females (low F) or males (high F).

---
# NOTE: 12) 	
#       i) Checks for individuals with X (F) and Y (Call Rate) call rates < specific thresholds so identify outlyers indictive of sex chr abnormalities
#     	ii) Writes these individuals to file, but does not exclude them
---
```{r qc0 fig X, fig.align="center"}
bim <- read_table2(paste0(outpath,"/",DATASET,".bim"), col_names=c("CHR","SNP","cm","BP","A1","A2"))
bim <- bim[bim$CHR != 0,]

if(nrow(bim[bim$CHR %in% c("23","X"),])>0 & nrow(bim[bim$CHR %in% c("24","Y"),])>0){

qc3.fam=read.table(file=paste(outpath,"/",DATASET,".qc3.clean.fam",sep=""),header=F)

qc3.ids.keep=as.data.frame(do.call(rbind,lapply(1:nrow(qc3.fam),function(x){
  fid=qc3.fam[x,1]
  iid=qc3.fam[x,2]
  
  overlap.check=qc0.dataset[which(qc0.dataset$FID==fid & qc0.dataset$IID==iid),]
  if(nrow(overlap.check)==1){
    overlap.check
  }
  })))

qc0.dataset.p1 <- ggplot(qc3.ids.keep, aes(x = F)) +
  geom_histogram(aes(y=..count..),binwidth=0.025, colour="darkgreen", fill="white") +
  geom_vline(xintercept=c(qc0.max.femaleF,qc0.min.maleF), linetype="dotted", colour="red") +
  labs(title="X-linked markers check",y="Number of samples",x="X-chromosome homozygosity (F)",color="") +
  theme_fivethirtyeight(base_family="sans") +
  theme(plot.background = element_rect(fill = "white"),
        axis.title=element_text())
qc0.dataset.p1
}
```

`r if(max(fam$Sex) <= 0 ){"No sex phenotypes were present in the genotype data, thus no individuals were removed after sex check."}`
`r if(max(fam$Sex) > 1 & nrow(bim[bim$CHR %in% c("23","X"),])>0 ){paste("Based on X-chromosome genotypes, PLINK's sex check function identified ",nrow(qc0.dataset.problem)," individuals where sex was discordant between genotype and phenotype data (male sex is defined as F>=",qc0.min.maleF," and female sex is defined as F<=",qc0.max.femaleF,". In addition, ",nrow(qc0.dataset.problem1)," individuals had missing sex phenotypes. Only individuals with discordant, rather than missing gender are excluded from further QC. ",sep="")}`
`r if(max(fam$Sex) == 1 & nrow(bim[bim$CHR %in% c("23","X"),])>0){paste("Based on X-chromosome genotypes, PLINK's sex check function identified ",nrow(qc0.dataset.problem)," individual where sex was discordant between genotype and phenotype data (male sex is defined as F>=",qc0.min.maleF," and female sex is defined as F<=",qc0.max.femaleF,". In addition, ",nrow(qc0.dataset.problem1)," individuals had missing sex phenotypes. Only individuals with ambiguous, rather than missing gender codes are excluded from further QC. ",sep="")}`

If data from both sex chromosomes are present, call rates at the Y-chromosome are used to assess the presence of individuals with sex-linked chromosomal disorders such as Turner (X0) or Klinefelter (XXY) syndromes. (Igo 2016, PMID: [27367164](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5100670/)). The call rate at the Y-chromosome also allows to distinguish the sex of moderately ambiguous samples. 

```{r qc0 sex-check XY, fig.align="center"}
if(nrow(bim[bim$CHR %in% c("24","Y"),])>0 & nrow(bim[bim$CHR %in% c("23","X"),])>0){

### Merge with F estimates
qc0.dataset <- left_join(qc3.ids.keep,qc0.y.dataset)

### If statement checks for whether the y call rates are in the expected range. It may be sufficient for sex checks, but not for calling sex chr abnormalities

if(max(qc0.dataset$YRATE)>0.5){

POSSIBLE.Gender.Chr.Abnormalities=unique(qc0.dataset[which((qc0.dataset$F>0.5 & qc0.dataset$YRATE<0.5) | (qc0.dataset$F<0.5 & qc0.dataset$YRATE>0.5) | (qc0.dataset$F>0.25 & qc0.dataset$F<0.75 & qc0.dataset$YRATE>0.5) | (qc0.dataset$F>0.25 & qc0.dataset$F<0.75 & qc0.dataset$YRATE<0.5)),][,1:2])
if(nrow(POSSIBLE.Gender.Chr.Abnormalities)>0){
write.table(POSSIBLE.Gender.Chr.Abnormalities,file=paste(outpath,"/",DATASET,".Abnormal.Sex.Chr.txt",sep=""),col.names=F,quote=F,row.names=F)
}
qc0.dataset.p2 <-ggplot(qc0.dataset, aes(x=F,y=YRATE))+
  geom_point(shape=21, size=4, colour="darkgreen", fill="white",alpha=0.75)+
  geom_vline(xintercept=c(qc0.max.femaleF,qc0.min.maleF), linetype="dotted", colour="red") +
  labs(title="Sex chromosome content",x="X-chromosome homozygosity (F)",y="Y-chromosome call rate") +
  theme_fivethirtyeight(base_family="sans") +
  theme(plot.background = element_rect(fill = "white"),
        axis.title=element_text())
qc0.dataset.p2
} 
}
```

`r if(nrow(bim[bim$CHR %in% c("24","Y"),])==0){paste0("No Y Chr genotype calls were present, hence sex chr abnormaity checks were skipped")} else if(nrow(bim[bim$CHR %in% c("24","Y"),])>0 & max(qc0.dataset$YRATE)<0.5){paste0("Y Chr call rates were low, hence sex chr abnormaity checks were skipped")} else if(nrow(bim[bim$CHR %in% c("24","Y"),])>0 & max(qc0.dataset$YRATE)<0.5 & nrow(POSSIBLE.Gender.Chr.Abnormalities)==0){paste0("No sex chromosome abnormalities were detected")} else if(nrow(bim[bim$CHR %in% c("24","Y"),])>0 & max(qc0.dataset$YRATE)<0.5 & nrow(POSSIBLE.Gender.Chr.Abnormalities)>0){paste0("Sex chromosome abnormalities were detected in ",nrow(POSSIBLE.Gender.Chr.Abnormalities)," individuals")}`

---
# NOTE: 13) 	
#     	i) Renames NA chr to X in qc3.bim 
#	      ii) Loops over each chr, saves to vcf format and sorts the resulting file
#     	iii) This is now in the correct format for imputation of autosomal and X chrs using Michigan Imputation Server
---

```{r 13i 13ii 13iii, include=FALSE}

#### Convert output to VCF format

# i) Renames NA chr to X in qc3.bim 
qc3.bim$CHR[is.na(qc3.bim$CHR)] <- "X"
write.table(qc3.bim,file=paste(outpath,"/",DATASET,".qc3.clean.bim",sep=""),col.names=F,quote=F,row.names=F)

#	ii) Loops over each chr, saves to vcf format and sorts the resulting file
lapply(c(1:22,"X"),function(chr){
  system(paste(PLINK," --bfile ",outpath,"/",DATASET,".qc3.clean --output-chr M --recode vcf --chr ",chr," --out ",outpath,"/",DATASET,".",chr,".qc3.clean",sep=""))
  system(paste(vcfsort," ",outpath,"/",DATASET,".",chr,".qc3.clean.vcf | /home/c.c1002680/Software/samtools-1.9/htslib-1.9/bin/bgzip -c > ",outpath,"/",DATASET,".",chr,".qc3.clean.sorted.vcf.gz",sep=""))
})
```

## QC Step 5: Relatedness

The SNPRelate R-package was used to convert the PLINK data into a Genomic Data Structure (GDS) file for use with the GENESIS suite. The current implementation of GENESIS provides functions to perform PC-AiR (Conomos 2015, PMID: [25810074](https://onlinelibrary.wiley.com/doi/abs/10.1002/gepi.21896)) and PC-Relate (Conomos 2016, PMID: [26748516](https://www.sciencedirect.com/science/article/pii/S0002929715004930)). PC-AiR performs a Principal Components Analysis on genome-wide SNP data for the detection of population structure in a sample that may contain known or cryptic relatedness. Unlike standard PCA, PC-AiR accounts for relatedness in the sample to provide accurate ancestry inference that is not confounded by family structure.

---
# NOTE: 14) 	
#     	i) Converts bed/bim/fam into GDS format
#	      ii) Estimate relatedness using KING robust method
#     	iii) Perform LD pruning removing blacklisted regions from Price et al containing long range ld regions
#     	iv) Derive PCAs 
#     	v) Generate PCA plot (not this does not include integration with other population reference panels)
#     	vi) PC-Relate uses these ancestry-representative principal components to adjust for population structure and accurately estimate measures of recent genetic relatedness, of which #           the one of interest here is the kinship coefficient Phi. This can be interpreted in the same way as the PLINK relatedness metric pihat.
#     	vii) Generate relatedness plot
#     	viii) Identify number of duplicate samples. Cannot distinguish between dups and mz twins. 
---
```{r 14i file conversion, include=FALSE}
### Transform PLINK file into GDS file
system(paste(PLINK," --bfile ",outpath,"/",DATASET,".qc3.clean --autosome --make-bed --out ",outpath,"/",DATASET,".qc4.clean",sep=""))
qc4.bim <- read_table2(paste0(outpath,"/",DATASET,".qc4.clean.bim"), col_names=c("CHR","SNP","cm","BP","A1","A2"))

snpgdsBED2GDS(bed.fn=paste0(DATASET,".qc4.clean.bed"),bim.fn=paste0(DATASET,".qc4.clean.bim"),fam.fn=paste0(DATASET,".qc4.clean.fam"),out.gdsfn=paste(DATASET,".qc4.clean.gds",sep=""))

```

```{r 14ii, include=FALSE}
### Load GDS for KING
genodata <- snpgdsOpen(filename=paste0(outpath,"/",DATASET,".qc4.clean.gds"))
### Estimate relatedness using KING-robust method
kindata <- snpgdsIBDKING(genodata)
colnames(kindata$kinship) <- kindata$sample.id
rownames(kindata$kinship) <- kindata$sample.id
```

```{r 14 iii, include=FALSE}
### Retrieve the Price 2008 (PMID:18606306) long-range LD regions
lrld <- read.table(file="/home/c.c1002680/Pathfinder/GenoQCPipeExtra/lrld.txt",header=T)
snp.lrld <- rep(TRUE, nrow(qc4.bim))
for (f in 1:nrow(lrld)) {
snp.lrld[qc4.bim$CHR == lrld$Chr[f] & lrld$Start[f] < qc4.bim$BP & qc4.bim$BP < lrld$Stop[f]] <- FALSE}
snp.sel <- qc4.bim$SNP[snp.lrld]
### Estimate LD independent SNPs after removing long-range LD regions

qc4.fam=read.table(paste(outpath,"/",DATASET,".qc4.clean.fam",sep=""))
if(nrow(qc4.fam)>=500){
qc4.r2 <- 0.2 # Minimum r2 for PCA (use 0.4 when sample size < 500, 0.2 otherwise)
} else if(nrow(qc4.fam)<500){
  qc4.r2=0.4
}

snpindep <- snpgdsLDpruning(genodata, snp.id=snp.sel, maf=qc4.maf, ld.threshold=qc4.r2)
snpindep <- unlist(snpindep)
snpgdsClose(genodata)
```

```{r 14 iv, include=FALSE}
### Load GDS for PC-Air
genodata <- GdsGenotypeReader(paste0(outpath,"/",DATASET,".qc4.clean.gds"))
genodata <- GenotypeData(genodata)
### Generate robust PCs with PC-Air
rpcdata <- pcair(genodata,kinobj=kindata$kinship,divobj=kindata$kinship,snp.include=snpindep)
```

```{r 14 v, fig.align="center"}
qc4.fam <- read_table2(paste0(outpath,"/",DATASET,".qc4.clean.fam"), col_names=c("FID","IID","PatID","MatID","Sex","Pheno"))
qc4.pca <- as.data.frame(rpcdata$vectors)
colnames(qc4.pca) <- paste0("PC",1:20)
qc4.pca <- cbind(subset(qc4.fam,select=c("FID","IID")),qc4.pca)
write.table(qc4.pca,file=paste0(outpath,"/",DATASET,".qc4.pcair.eigenvec"),col.names=T,row.names=F,quote=F,sep="\t")
rpcdata.p1 <- ggplot(qc4.pca, aes(x = PC1, y= PC2)) +
  geom_point(shape=21, alpha = 0.75,size = 5, colour="darkgreen", fill="white") +
 labs(title=paste("PC-AiR on",length(snpindep),"LD-independent markers"),y="PC2",x="PC1",color="") +
  theme_fivethirtyeight(base_family="sans") +
  theme(plot.background = element_rect(fill = "white"),
        axis.title=element_text())
rpcdata.p1
```

PC-Relate uses these ancestry-representative principal components to adjust for population structure and accurately estimate measures of recent genetic relatedness, of which the one of interest here is the kinship coefficient $\Phi$. This can be interpreted in the same way as the PLINK relatedness metric $\hat\pi{}$. Kinship values and proportions of SNPs with 0 IBD alleles are shown below, rescaled to the equivalent values produced by PLINK. These metrics can be used to identify groups of individuals with different degrees of relatedness (Manichaikul 2010, PMID: [20926424](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3025716/)).

```{r 14 vi,include=FALSE}
### Generate robust kinship estimates
genoiter <- GenotypeBlockIterator(genodata, snpBlock=10000,snpInclude=snpindep)
phidata <- pcrelate(genoiter,pcs=rpcdata$vectors[,1:qc4.pcairs],training.set=rpcdata$unrels,scale="overall",small.samp.correct=(length(getScanID(genodata)) <= 100))
close(genodata)
phiframe <- phidata$kinBtwn
# Assign relatedness based on kinship/IBD0
phiframe$relatedness <- ibdAssignRelatednessKing(kc=phiframe$kin, ibs0=phiframe$k0)
phiframe$relatedness <- factor(phiframe$relatedness,levels=c("Dup","PO","FS","Deg2","Deg3","U","Q"),labels=c("Duplicates/Twins","Parent-Offspring","Full Siblings","2nd Degree","3rd Degree","Unrelated","Unknown"))
### Correct kinship estimates to make it equivalent to PLINK IBD
phiframe$kin <- phiframe$kin * 2 
phiframe$kin[phiframe$kin < 0] <- 0 
phiframe$kin[phiframe$kin > 1] <- 1
### Output related individuals
write.table(phiframe[phiframe$relatedness != "Unrelated",],file=paste0(DATASET,".qc4.pcrelate.kin"),col.names=T,row.names=F,quote=F,sep="\t")
```

```{r 14 vii, fig.align="center"}
range01 <- function(x){(x-min(x))/(max(x)-min(x))} # Custom function to do 0-1 standardisation
phiframe$p0 <- range01(phiframe$k0)
phiframe.p1 <- ggplot(phiframe, aes(x = p0, y= kin,fill=relatedness)) +
  geom_point(shape=21, alpha = 0.5,size = 5, colour="darkgreen") +
  scale_fill_manual("",values=c("Duplicates/Twins"="indianred","Parent-Offspring"="orchid","Full Siblings"="yellow","2nd Degree"="skyblue","3rd Degree"="seagreen","Unrelated"="white","Unknown"="gray")) +
  labs(title="PC-Relate pairwise allele-sharing estimates",y="Kinship coefficient",x="Proportion of SNPs with 0 IBS alleles",color="") +
  theme_fivethirtyeight(base_family="sans") +
  theme(plot.background = element_rect(fill = "white"),
        axis.title=element_text(),
        legend.position="right",
        legend.direction = "vertical")
phiframe.p1
```

```{r 14 viii, warning=FALSE}
### Output duplicated individuals
qc4.duplicates <- phiframe[phiframe$relatedness == "Duplicates/Twins",]
qc4.duplicates <- unlist(subset(qc4.duplicates,select=c("ID1","ID2")))
qc4.duplicates <- data.frame(IID=qc4.duplicates)
qc4.duplicates <- right_join(qc4.fam, qc4.duplicates)
qc4.duplicates <- subset(qc4.duplicates,select=c("FID", "IID"))
if(nrow(qc4.duplicates)>0) {
write.table(qc4.duplicates, file=paste0(outpath,"/",DATASET,".qc4.pcrelate.dup"), col.names=F, row.names=F, quote = F)}
```

PC-Relate identified `r nrow(phiframe[phiframe$kin >= qc4.kin,])` pairs of individuals with kinship $\Phi\geq$ `r percent(qc4.kin)`. Among those, a total of `r nrow(qc4.duplicates)/2` pairs were flagged as duplicates or monozygotic twins. 

```{r 15i, include=FALSE}
# Read in data from PLINK files
fam <- read_table2(paste0(DATASET,".qc4.clean.fam"), col_names=c("FID","IID","PatID","MatID","Sex","Pheno"))
bim <- read_table2(paste0(DATASET,".qc4.clean.bim"), col_names=c("CHR","SNP","cm","BP","A1","A2"))
ref1_fam <- read_table2(paste0(miscfolder,"/",REF.PANEL,".fam"), col_names=c("FID","IID","PatID","MatID","Sex","Pheno"))
ref1_bim <- read_table2(paste0(miscfolder,"/",REF.PANEL,".bim"), col_names=c("CHR","SNP","cm","BP","A1","A2"))

# Merge input and reference data
plink_aim0_merge <- paste0(PLINK," --bfile ",DATASET,".qc4.clean --bmerge ",miscfolder,"/",REF.PANEL," --geno 0.01 --make-bed --out ",DATASET,".ref --allow-no-sex")
system(plink_aim0_merge, ignore.stderr = F) # If strand errors occur, they'll appear in the console
snpgdsBED2GDS(bed.fn=paste0(DATASET,".ref.bed"),bim.fn=paste0(DATASET,".ref.bim"),fam.fn=paste0(DATASET,".ref.fam"),out.gdsfn=paste0(DATASET,".ref.gds"))
### Load GDS for KING
genodata <- snpgdsOpen(filename=paste0(DATASET,".ref.gds"))
### Estimate relatedness using KING-robust method
kindata <- snpgdsIBDKING(genodata)
colnames(kindata$kinship) <- kindata$sample.id
rownames(kindata$kinship) <- kindata$sample.id
snpgdsClose(genodata)
```
## QC Step 6: Global biogeographical ancestry inference 

This analysis is based on the set of Ancestry Informative Markers (AIMs) contained in the EUROFORGEN (PMID: [24631693](https://www.sciencedirect.com/science/article/pii/S1872497314000404), [27208666](https://www.sciencedirect.com/science/article/pii/S1872497316300643)) and Kidd (PMID: [24508742](https://www.sciencedirect.com/science/article/pii/S1872497314000039)) panels. The original sets contain a grand total of 167 AIMs, but these have been restricted based on availability in the `r paste0(DATASET.NAME)` dataset.

As a reference panel, a combination of Human Genome Diversity Project (PMID: [18292342](http://science.sciencemag.org/content/319/5866/1100)) and South Asian Genome Project (PMID: [25115870](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0102645)) is used, which contains `r nrow(ref1_fam)` samples from 62 worldwide populations. 

```{r 15ii, include=F}
# Read in data for the global AIM set and its tags (ordered by r2)
global.tags <- read_table2(paste(miscfolder,"/Kidd2014_Phillips2014_167AIM.tags.list",sep=""),na="NONE")
global.tags$TAG1 <- global.tags$SNP # Add each SNP as its first tag
global.tags2 <-  read.table(text=global.tags$TAGS, sep = "|", colClasses = "character", fill=T, na.strings = c("", "NA"), col.names=paste0("TAG",2:max(str_count(global.tags$TAGS,"\\|")+2,na.rm=T)))
global.tags <- cbind(subset(global.tags,select="SNP"),subset(global.tags,select="TAG1"),global.tags2)
rm(global.tags2)
# Organise data as a sorted dataframe
global.tags <- melt(global.tags,id.vars="SNP",value.name="tagsnp",variable.name="tagorder",na.rm=T)
global.tags <- global.tags[with(global.tags,order(SNP,tagorder)),]
global.tags$tagorder <- gsub("[^0-9.-]", "", global.tags$tagorder)
# Select SNPs present in the data and reference (or closest tag)
global.tags$geno <- (global.tags$tagsnp %in% bim$SNP & global.tags$tagsnp %in% ref1_bim$SNP)
global.tags <- subset(global.tags,geno==T)
global.tags <- global.tags[match(unique(global.tags$SNP), global.tags$SNP),]
global.snps <- unique(global.tags$tagsnp)
write.table(global.snps, paste0(DATASET,".aim1.snp"), quote=F,col.names = F,row.names=F)
rm(global.tags)

# NOTE: The following chunk requires both input and reference data to have been run through Genotype Harmoniser
# with a common reference panel (i.e. HRC). Beware of SNP strand misalignments otherwise!

# Merge input and reference data retrieving only the AIMs
system(paste0(PLINK," --bfile ",outpath,"/",DATASET,".qc4.clean --extract ",DATASET,".aim1.snp --make-bed --out ",DATASET,".aim1 --allow-no-sex"))
system(paste(PLINK," --bfile ",miscfolder,"/",REF.PANEL," --extract ",DATASET,".aim1.snp --make-bed --out ",REF.PANEL,".aim1 --allow-no-sex",sep=""))
system(paste0(PLINK," --bfile ",DATASET,".aim1 --bmerge ",REF.PANEL,".aim1 --make-bed --out ",DATASET,".ref1 --allow-no-sex"))
```

```{r 15iii, include=FALSE}
# Transform merged PLINK file into GDS file
snpgdsBED2GDS(bed.fn=paste0(DATASET,".ref1.bed"),bim.fn=paste0(DATASET,".ref1.bim"),fam.fn=paste0(DATASET,".ref1.fam"),out.gdsfn=paste0(DATASET,".ref1.gds"))
genodata <- GdsGenotypeReader(paste(outpath,"/",DATASET,".ref1.gds",sep=""))
genodata <- GenotypeData(genodata)
# Generate PCs for LDA
pcdata <- pcair(genodata,kinobj=kindata$kinship,divobj=kindata$kinship,unrel.set=ref1_fam$IID,eigen.cnt=max.aimpcs) # Base PCs on the reference panel
pca.aim1 <- as.data.frame(pcdata$vectors)
close(genodata)
```

```{r 15iv, fig.align="center"}
# Add sample and variable names to PCA frame
colnames(pca.aim1) <- paste0("PC",c(1:max.aimpcs))

### LH BUGFIX FOR IDS
fam.fix=read.table(file=paste0(DATASET,".ref1.fam"),header=F,stringsAsFactors = FALSE)
new.id.vector=paste(fam.fix[,1],"_",fam.fix[,2],sep="")
###


pca.aim1$ID <- rownames(pca.aim1)
pca.aim1$ID=gsub("-","_",pca.aim1$ID)
rownames(pca.aim1)=pca.aim1$ID

# Restrict to Tracy-Widom significant PCs or the first 5 (if fewer than 5)
pca.aim1.tw <- tw(pcdata$values,max.aimpcs,criticalpoint = 0.9793)$SigntEigenL
if (pca.aim1.tw < 5) {pca.aim1.tw <- 5}
rm(pcdata)
# Load reference population data and merge with PCs
ref1.pop <- read.delim(paste0(miscfolder,"/",REF.PANEL,"_PopInfo.txt"),header=T,stringsAsFactors = F)
ref1.pop <- subset(ref1.pop, select=c("ID","Population","Region"))

ref1.pop.HGDP=ref1.pop[grep("HGDP",ref1.pop$ID),]
#ref1.pop.HGDP$ID=paste("0_",ref1.pop.HGDP$ID,sep="")

ref1.pop.SAGP=ref1.pop[grep("SAGP",ref1.pop$ID),]
ref1.pop.SAGP$ID=paste(ref1.pop.SAGP$ID,"_",ref1.pop.SAGP$ID,sep="")

ref1.pop=rbind(ref1.pop.HGDP,ref1.pop.SAGP)


pca.aim1 <- left_join(pca.aim1,ref1.pop,by=c("ID"))
rownames(pca.aim1) <- pca.aim1$ID
pca.aim1$Population[is.na(pca.aim1$Population)] <- DATASET.NAME
pca.aim1$Region[is.na(pca.aim1$Region)] <- DATASET.NAME 
pca.aim1 <- subset(pca.aim1, Population != "Uygur") # Exclude Uyghurs due to unusual admixture
pca.aim1$Region <- factor(pca.aim1$Region, levels=c("Africa","Middle_East","Europe","Central_South_Asia","East_Asia","America","Oceania",DATASET.NAME), labels=c("Subsaharan African","North African","European","Southwest Asian","East Asian","Native American","Oceanian",DATASET.NAME))
pca.aim1 <- with(pca.aim1, pca.aim1[order(Region,ID),]) # Sort for plotting purposes
# Plot ancestries
pca.aim1.p1 <- ggplot(pca.aim1, aes(x = PC1, y= PC2,fill=Region))+
  geom_point(aes(shape=Region),alpha = 0.75,size = 3, colour="black") +
  scale_shape_manual("",values=c(rep(21,7),22)) +
  scale_fill_manual("",values=c("red","firebrick","blue","purple","pink","yellow","green","white")) +
  labs(title="",y="PC2",x="PC1") +
  theme_fivethirtyeight(base_family="sans") +
  theme(plot.title = element_blank(),
        plot.background = element_rect(fill = "white"),
        axis.title=element_text(),
        legend.position="top",
        legend.direction="horizontal")
pca.aim1.p2 <- ggplot(pca.aim1, aes(x = PC3, y= PC4,fill=Region))+
  geom_point(aes(shape=Region),alpha = 0.75,size = 3, colour="black") +
  scale_shape_manual("",values=c(rep(21,7),22)) +
  scale_fill_manual("",values=c("red","firebrick","blue","purple","pink","yellow","green","white")) +
  labs(title="",y="PC4",x="PC3") +
  theme_fivethirtyeight(base_family="sans") +
  theme(plot.title = element_blank(),
      plot.background = element_rect(fill = "white"),
        axis.title=element_text(),
        legend.position="none")
pca.aim1.legend <- get_legend(pca.aim1.p1 + theme(legend.background = element_rect(fill = "white")))
pca.aim1.title <- ggdraw() + draw_label(paste("PCA on",length(global.snps),"AIMs for global ancestry inference"), fontface='bold')
pca.aim1.p1p2 <- plot_grid(pca.aim1.p1+theme(legend.position="none"), pca.aim1.p2,
           align = 'vh', hjust = -1, nrow = 1, rel_widths = c(1, 1))
plot_grid(pca.aim1.title,pca.aim1.legend, pca.aim1.p1p2, ncol=1, rel_heights=c(0.15,0.1, 1)) 
```

Ancestry inference is based on Fisher's Linear Discriminant Analysis algorithm (PMID: [16193326](https://link.springer.com/article/10.1007%2Fs00439-005-0012-1)), which has been applied to the first `r paste0(pca.aim1.tw)` principal components of the HGDP+SAGP dataset. This optimal number of PCs has been determined using the Tracy-Widom test for eigenvalues (PMID: [17194218](https://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.0020190)). Model training statistics for the prediction of each individual biogeographical ancestry using the available `r length(global.snps)` AIMs are shown below.

```{r 15v}
# Create and train LDA model
pca.aim1.test.data <- subset(pca.aim1,Region == DATASET.NAME,select=paste0("PC",c(1:pca.aim1.tw)))
pca.aim1.train.data <- subset(pca.aim1,!Region == DATASET.NAME,c("Region",paste0("PC",c(1:pca.aim1.tw))))
pca.aim1.train.class <- str_replace_all(as.character(pca.aim1.train.data$Region)," ","_") # Replace spaces with underscores
pca.aim1.train.data$Region <- NULL
lda.train.aim1 <- train(x=pca.aim1.train.data,y=pca.aim1.train.class, method="lda", metric="Accuracy", trControl=trainControl(method="cv", number=10, classProbs = T, savePredictions = T))
# Output results of LDA model
lda.train.cm <- confusionMatrix(lda.train.aim1$pred$obs,lda.train.aim1$pred$pred)
lda.train.cm <- lda.train.cm$byClass[,c("Sensitivity","Specificity","Pos Pred Value","Neg Pred Value","Balanced Accuracy")]
rownames(lda.train.cm) <- gsub("Class: ", "", rownames(lda.train.cm)) # Remove the string "Class:"
rownames(lda.train.cm) <- str_replace_all(rownames(lda.train.cm),"_"," ") # Bring the spaces back
lda.train.cm[] <- sprintf("%.2f%%", 100 * lda.train.cm) # Replace numbers with percentages
# Plot table and reorder for consistency with PCA plot
kable(lda.train.cm[c("Subsaharan African","North African","European","Southwest Asian","East Asian","Native American","Oceanian"),]) %>%
  kable_styling(bootstrap_options = c("striped"))
```

A threshold for ancestry inference has been set at `r percent(min.prob.aim1)` probability. Any individual not achieving this probability for any ancestry has been labelled _"Unclassified"_. Inspection of `r paste0(DATASET,".aim.global.prob.txt")` in the Ancestry folder can be helpful for the resolution of unclassified individuals, some of which might show a relatively simple admixture pattern. 

```{r 15vi}
# Predict ancestries in the input data
lda.test.aim1 <- predict(object=lda.train.aim1,newdata=pca.aim1.test.data,type="prob")
lda.test.aim1 <- round(lda.test.aim1,3) # Restrict output to three decimal places

lda.test.aim1$ID <- rownames(lda.test.aim1)

fam$FID=as.character(fam$FID)
fam$IID=as.character(fam$IID)

fam$ID=paste(fam$FID,"_",fam$IID,sep="")
lda.test.aim1 <- left_join(subset(fam,select=c("ID","FID","IID")),lda.test.aim1,by="ID")

if(length(which(is.na(lda.test.aim1)))>300){
lda.test.aim1 <- predict(object=lda.train.aim1,newdata=pca.aim1.test.data,type="prob")
lda.test.aim1 <- round(lda.test.aim1,3) # Restrict output to three decimal places

lda.test.aim1$ID <- rownames(lda.test.aim1)

fam$FID=as.character(fam$FID)
fam$IID=as.character(fam$IID)
fam$ID=paste(fam$FID,"_",fam$IID,sep="")

lda.test.aim1 <- merge(subset(fam,select=c("ID","FID","IID")),lda.test.aim1,by.x="IID",by.y="ID")
}

# Report predicted ancestries
lda.test.aim1$Ancestry <- "Unclassified"
lda.test.aim1$Ancestry[lda.test.aim1$East_Asian >= min.prob.aim1] <- "East Asian"
lda.test.aim1$Ancestry[lda.test.aim1$European >= min.prob.aim1] <- "European"
lda.test.aim1$Ancestry[lda.test.aim1$Native_American >= min.prob.aim1] <- "Native American"
lda.test.aim1$Ancestry[lda.test.aim1$North_African >= min.prob.aim1] <- "North African"
lda.test.aim1$Ancestry[lda.test.aim1$Oceanian >= min.prob.aim1] <- "Oceanian"
lda.test.aim1$Ancestry[lda.test.aim1$Southwest_Asian >= min.prob.aim1] <- "Southwest Asian"
lda.test.aim1$Ancestry[lda.test.aim1$Subsaharan_African >= min.prob.aim1] <- "Subsaharan African"
lda.test.aim1$Ancestry <- factor(lda.test.aim1$Ancestry, levels=c("Subsaharan African","North African","European","Southwest Asian","East Asian","Native American","Oceanian","Unclassified"))
lda.test.aim1.table <- as.data.frame(table(lda.test.aim1$Ancestry))
colnames(lda.test.aim1.table) <- c("Ancestry","Samples")
kable(lda.test.aim1.table) %>% kable_styling(full_width = F, bootstrap_options = c("striped"))
write.table(lda.test.aim1,file=paste0(DATASET,".aim.global.prob.txt"),col.names=T,row.names=F,quote=F,sep="\t")

lda.test.aim1.eur_swa <- subset(lda.test.aim1,lda.test.aim1$European >= min.prob.admx | lda.test.aim1$North_African >= min.prob.admx | lda.test.aim1$Southwest_Asian >= min.prob.admx,select=c("FID","IID"))
ref.aim1.eur_swa <- subset(ref1.pop,Region %in% c("Middle_East","Europe","Central_South_Asia"),select=c("ID"))
ref.aim1.eur_swa <- subset(ref1_fam,IID %in% ref.aim1.eur_swa$ID,select=c("FID","IID"))
write.table(lda.test.aim1.eur_swa, file=paste0(DATASET,".eur_swa.aim1.ids"), col.names=F, row.names=F, quote = F)
write.table(ref.aim1.eur_swa, file=paste0(REF.PANEL,".eur_swa.ids"), col.names=F, row.names=F, quote = F)

lda.test.aim.final <- subset(lda.test.aim1,select=c("FID","IID","Ancestry"))
colnames(lda.test.aim.final) <- c("FID","IID","Global_model")
write.table(lda.test.aim.final,file=paste0(DATASET,".aim.global.classification.txt"),col.names=T,row.names=F,quote=F,sep="\t")
#Ancestry assignments for each `r paste0(DATASET.NAME)` sample are given in the file _`r paste0(DATASET,".aim_classification.txt")`_All individuals classified as "European", "North African" or "Southwest Asian", or with greater than `r percent(min.prob.admx)` ancestry from these regions are eligible for a second round of analyses to confirm this assignment.
```

## Miscellaneous information and directory information 
`r nrow(bim)` autosomal SNPs and `r nrow(fam)` individuals have passed quality control.  

### Genotypes
**QC'd autosomal genotypes (Plink format):** _`r paste0(DATASET,".qc4.clean.bed/bim/fam")`_  
**QC'd autosomal genotypes (R format):** _`r paste0(DATASET,".qc4.clean.gds")`_  

### Genotypes/YChr and/or Genotypes/Mito
**Non-QC'd Y Chr:** _`r if(file.exists(paste0(DATASET,".Y.bed"))==T){paste0("Genotypes/YChr/",DATASET,".Y.bed/bim/fam")} else if(file.exists(paste0(DATASET,".Y.bed"))==F){paste0("No Y Chr SNPs were present")}`_  
**Non-QC'd Mitochondrial SNPs:** _`r if(nrow(mito) > 0 ){paste0(DATASET,".Mitochondria.bed/bim/fam")} else if(nrow(mito) <= 0 ){paste0("No mitochondrial SNPs were present")}`_

### Genotypes/Logs

**Low quality SNPs removed:** _`r if(nrow(qc1.dataset.problem) > 0 ){paste0(DATASET,".qc1.exclude")} else if(nrow(qc1.dataset.problem) <= 0 ){paste0("No SNPs were removed due to low genotyping")}`_  
**Low quality samples removed:** _`r if(nrow(qc2.dataset.problem) > 0 ){paste0(DATASET,".qc2.remove")} else if(nrow(qc2.dataset.problem) <= 0 ){paste0("No individuals were removed due to genotype missingness")}`_  
**Gender mismatches removed:** _`r if(file.exists(paste0(DATASET,".qc0.remove"))==T){paste0(DATASET,".qc0.remove")} else if(max(fam$Sex) <= 0 | file.exists(paste0(DATASET,".qc0.remove"))==F){paste0("No individuals were removed due to gender mismatches")}`_   
**Individuals with sex chr abnormalities:** _`r if(file.exists(paste0(DATASET,".Abnormal.Sex.Chr.txt"))==T){paste0(DATASET,".Abnormal.Sex.Chr.txt")} else if(file.exists(paste0(DATASET,".Abnormal.Sex.Chr.txt"))==F){paste0("No individuals were identified with possible sex chromosome abnormalities")}`_   
**Duplicate samples identified:** _`r if(file.exists(paste0(DATASET,".qc4.pcrelate.dup"))==T){paste0(DATASET,".qc4.pcrelate.dup")} else if(file.exists(paste0(DATASET,".qc4.pcrelate.dup"))==F){paste0("No duplicate individuals were identified")}`_ 

### Ancestry/
**PC-AiR components for all curated samples:** _`r paste0(DATASET,".qc4.pcair.eigenvec")`_  
**PC-Relate kinship estimates for partially related samples:** _`r paste0(DATASET,".qc4.pcrelate.kin")`_  
**Ancestry classification using ancestry informative markers:** _`r paste0(DATASET,".aim.global.classification.txt")`_  

### ImputeMe/
**Sorted VCF files aligned to Haplotype Reference Consortium V1.1:** _`r paste0(DATASET,".[1-22,X].qc3.clean.sorted.vcf.gz")`_  


---
# NOTE: 15) 	
# i) Cleanup of intermediate files during the pipeline

---
```{r FinalDirs, warning=F}

dir.create("Ancestry")
system(paste("mv *pcair.eigenvec Ancestry/"))
system(paste("mv *pcrelate.kin Ancestry/"))
system(paste("mv *.aim.global.classification.txt Ancestry/"))
system(paste0("mv *.aim.global.prob.txt Ancestry/"))

if(file.exists(paste(DATASET,".Y.bed",sep=""))==T){
dir.create("Genotypes/YChr")
system(paste("mv *.Y* Genotypes/YChr/"))
}

if(file.exists(paste(DATASET,".Mitochondria.bed",sep=""))==T){
dir.create("Genotypes/Mito")
system(paste("mv *.Mito* Genotypes/Mito/"))
}

dir.create("Genotypes/Logs")
system(paste("mv *.sexcheck Genotypes/Logs/"))
system(paste("mv *.exclude Genotypes/Logs/"))
system(paste("mv *.remove Genotypes/Logs/"))
system(paste("mv *.txt Genotypes/Logs/"))
system(paste("mv *.log Genotypes/Logs/"))
system(paste("mv *.dup Genotypes/Logs/"))


dir.create("Genotypes/AutosomalPlusX")
system(paste("mv ",DATASET,".qc3.clean.bed Genotypes/AutosomalPlusX/",sep=""))
system(paste("mv ",DATASET,".qc3.clean.bim Genotypes/AutosomalPlusX/",sep=""))
system(paste("mv ",DATASET,".qc3.clean.fam Genotypes/AutosomalPlusX/",sep=""))

dir.create("Genotypes/Autosomal")
system(paste("mv ",DATASET,".qc4.clean.bim Genotypes/Autosomal/",sep=""))
system(paste("mv ",DATASET,".qc4.clean.fam Genotypes/Autosomal/",sep=""))
system(paste("mv ",DATASET,".qc4.clean.gds Genotypes/Autosomal/",sep=""))
system(paste("mv ",DATASET,".qc4.clean.bed Genotypes/Autosomal/",sep=""))


dir.create("ImputeMe")
system(paste("mv *qc3.clean.sorted.vcf.gz ImputeMe/"))
system(paste("mv *.*.qc3.clean.log ImputeMe/"))

if(file.exists(paste(outpath,"/",DATASET,".ped",sep=""))==F & FIDUPDATE==F & SEXUPDATE==F){

system(paste("mv ",DATASET,".bed Genotypes/OriginalGenotypes/",sep=""))
system(paste("mv ",DATASET,".bim Genotypes/OriginalGenotypes/",sep=""))
system(paste("mv ",DATASET,".fam Genotypes/OriginalGenotypes/",sep=""))

}

if(file.exists(paste(DATASET,".ped",sep=""))==T){
system(paste0("mv ",DATASET,".ped Genotypes/OriginalGenotypes/"))
system(paste0("mv ",DATASET,".map Genotypes/OriginalGenotypes/"))
}


dir.create("Scripts")
system(paste("mv *.err Scripts/"))
system(paste("mv *.out Scripts/"))
#system(paste0("mv HAWK.PsychmedGenotypeQC.Beta.V1.2.",DATASET,".Rmd Scripts/"))
#system(paste0("mv HAWK.PsychmedGenotypeQC.Alpha.V1.2.sh Scripts/HAWK.Pathfinder.Alpha.V1.2.",DATASET,".sh"))



### Remove all intermediate genotype files and ancestral data apart from relevant files
system(paste("rm ",outpath,"/",DATASET,"1*",sep=""))
system(paste("rm ",outpath,"/",DATASET,"1*",sep=""))
system(paste("rm ",outpath,"/",DATASET,"1*",sep=""))

system(paste("rm ",outpath,"/",DATASET,".gh.bed",sep=""))
system(paste("rm ",outpath,"/",DATASET,".gh.bim",sep=""))
system(paste("rm ",outpath,"/",DATASET,".gh.fam",sep=""))
system(paste("rm ",outpath,"/",DATASET,"*.nosex",sep=""))
system(paste("rm ",outpath,"/",DATASET,".qc0.clean.hh",sep=""))
system(paste("rm ",outpath,"/",DATASET,".qc0.clean.bed",sep=""))
system(paste("rm ",outpath,"/",DATASET,".qc0.clean.bim",sep=""))
system(paste("rm ",outpath,"/",DATASET,".qc0.clean.fam",sep=""))
system(paste("rm ",outpath,"/",DATASET,".*.nosex",sep=""))
system(paste("rm ",outpath,"/",DATASET,".qc1.clean.hh",sep=""))
system(paste("rm ",outpath,"/",DATASET,".qc1.clean.bed",sep=""))
system(paste("rm ",outpath,"/",DATASET,".qc1.clean.bim",sep=""))
system(paste("rm ",outpath,"/",DATASET,".qc1.clean.fam",sep=""))
system(paste("rm ",outpath,"/",DATASET,".qc2.clean.hh",sep=""))
system(paste("rm ",outpath,"/",DATASET,".qc2.clean.bed",sep=""))
system(paste("rm ",outpath,"/",DATASET,".qc2.clean.bim",sep=""))
system(paste("rm ",outpath,"/",DATASET,".qc2.clean.fam",sep=""))
system(paste("rm ",outpath,"/",DATASET,".*.vcf",sep=""))
system(paste("rm HGDP_SAGP.grc37*"))
system(paste("rm *aim1*"))
system(paste("rm *.ref.*"))
system(paste("rm *.ref1.*"))
system(paste("rm *.ids"))
system(paste("rm *.lmiss"))
system(paste("rm *.imiss"))
system(paste("rm *.ibd12"))
```
